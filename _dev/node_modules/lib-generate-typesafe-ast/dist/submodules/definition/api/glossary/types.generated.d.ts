import * as pt from 'pareto-core-types';
export declare namespace T {
    namespace Grammar {
        namespace globalValueTypes {
            type D = T.ValueType;
        }
        type globalValueTypes = pt.Dictionary<T.ValueType>;
        type root = T.Node2;
    }
    type Grammar = {
        readonly 'globalValueTypes': pt.Dictionary<T.ValueType>;
        readonly 'root': T.Node2;
    };
    namespace Node2 {
        type name = string;
        namespace _ltype {
            type composite = T.Value;
            namespace leaf {
                type hasTextContent = boolean;
            }
            type leaf = {
                readonly 'hasTextContent': boolean;
            };
        }
        type _ltype = ['composite', T.Value] | [
            'leaf',
            {
                readonly 'hasTextContent': boolean;
            }
        ];
    }
    type Node2 = {
        readonly 'name': string;
        readonly 'type': ['composite', T.Value] | [
            'leaf',
            {
                readonly 'hasTextContent': boolean;
            }
        ];
    };
    namespace Value {
        namespace cardinality {
            namespace array { }
            type array = {};
            namespace one { }
            type one = {};
            namespace optional { }
            type optional = {};
        }
        type cardinality = ['array', {}] | ['one', {}] | ['optional', {}];
        type _ltype = T.ValueType;
    }
    type Value = {
        readonly 'cardinality'?: ['array', {}] | ['one', {}] | ['optional', {}];
        readonly 'type': T.ValueType;
    };
    namespace ValueType {
        namespace choice {
            namespace options {
                type D = T.Value;
            }
            type options = pt.Dictionary<T.Value>;
        }
        type choice = {
            readonly 'options': pt.Dictionary<T.Value>;
        };
        type node = T.Node2;
        namespace reference {
            type name = string;
        }
        type reference = {
            readonly 'name': string;
        };
        namespace sequence {
            namespace elements {
                namespace A {
                    type name = string;
                    type value = T.Value;
                }
                type A = {
                    readonly 'name': string;
                    readonly 'value': T.Value;
                };
            }
            type elements = pt.Array<{
                readonly 'name': string;
                readonly 'value': T.Value;
            }>;
        }
        type sequence = {
            readonly 'elements': pt.Array<{
                readonly 'name': string;
                readonly 'value': T.Value;
            }>;
        };
    }
    type ValueType = [
        'choice',
        {
            readonly 'options': pt.Dictionary<T.Value>;
        }
    ] | ['node', T.Node2] | [
        'reference',
        {
            readonly 'name': string;
        }
    ] | [
        'sequence',
        {
            readonly 'elements': pt.Array<{
                readonly 'name': string;
                readonly 'value': T.Value;
            }>;
        }
    ];
}
