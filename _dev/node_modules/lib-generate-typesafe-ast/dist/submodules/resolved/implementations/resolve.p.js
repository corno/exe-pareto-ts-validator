"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.$$ = void 0;
const pl = __importStar(require("pareto-core-lib"));
const ps = __importStar(require("pareto-core-state"));
function createSubscribers() {
    return ps.createArrayBuilder();
}
function createSubscribeFunction(subscribers) {
    return (key, cb) => {
        subscribers.push({
            'name': key,
            'subscriber': cb
        });
    };
}
function resolve(subscribers, dict, onNotFound) {
    subscribers.getArray().forEach(($) => {
        let found = false;
        dict.forEach(() => false, (value, key) => {
            if ($.name === key) {
                found = true;
                $.subscriber(value);
            }
        });
        if (!found) {
            pl.logDebugMessage("NOT FOUND");
            onNotFound($.name);
        }
    });
}
const $$ = ($, $i) => {
    let hasError = false;
    function mapNode2($, parameters) {
        return pl.cc(($.context), ($) => {
            return {
                'name': $.name,
                'type': pl.cc($.type, ($) => {
                    switch ($[0]) {
                        case 'composite':
                            return pl.cc($[1], ($) => {
                                return ['composite', mapValue({
                                        'context': $,
                                    }, {
                                        'gt': parameters.gt
                                    })];
                            });
                        case 'leaf':
                            return pl.cc($[1], ($) => {
                                return ['leaf', {
                                        'hasTextContent': $.hasTextContent
                                    }];
                            });
                        default: return pl.au($[0]);
                    }
                }),
            };
        });
    }
    function mapValue($, parameters) {
        return pl.cc(($.context), ($) => {
            return {
                'cardinality': $.cardinality,
                'type': mapValueType({
                    'context': $.type,
                }, {
                    'gt': parameters.gt
                }),
            };
        });
    }
    function mapValueType($, parameters) {
        return pl.cc(($.context), ($) => {
            switch ($[0]) {
                case 'choice':
                    return pl.cc($[1], ($) => {
                        return ['choice', {
                                'options': $.options.map(($) => {
                                    return mapValue({
                                        'context': $,
                                    }, {
                                        'gt': parameters.gt,
                                    });
                                })
                            }];
                    });
                case 'node':
                    return pl.cc($[1], ($) => {
                        return ['node', mapNode2({
                                'context': $,
                            }, {
                                'gt': parameters.gt
                            })];
                    });
                case 'reference':
                    return pl.cc($[1], ($) => {
                        let x = null;
                        parameters.gt($.name, ($) => {
                            x = $;
                        });
                        return ['reference', {
                                'name': $.name,
                                'referencee': () => {
                                    if (x === null) {
                                        pl.panic(`Value should have been resolved: "${$.name}"`);
                                    }
                                    return x;
                                }
                            }];
                    });
                case 'sequence':
                    return pl.cc($[1], ($) => {
                        return ['sequence', {
                                'elements': $.elements.map(($) => {
                                    return {
                                        'name': $.name,
                                        'value': mapValue({
                                            'context': $.value,
                                        }, {
                                            'gt': parameters.gt
                                        }),
                                    };
                                })
                            }];
                    });
                default: return pl.au($[0]);
            }
        });
    }
    const subscribers = createSubscribers();
    const gvt = $.globalValueTypes.map(($) => {
        return mapValueType({
            'context': $,
        }, {
            'gt': createSubscribeFunction(subscribers)
        });
    });
    const out = {
        'globalValueTypes': gvt,
        'root': mapNode2({
            'context': $.root,
        }, {
            'gt': createSubscribeFunction(subscribers)
        }),
    };
    resolve(subscribers, gvt, ($) => {
        $i({
            'type': ['no such global value type', $]
        });
        hasError = true;
    });
    return hasError
        ? [false]
        : [true, out];
};
exports.$$ = $$;
